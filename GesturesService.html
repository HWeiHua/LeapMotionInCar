<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Leap Motion JavaScript Sample</title>
	<link rel="stylesheet" href="http://libs.baidu.com/bootstrap/3.1.1/css/bootstrap.min.css">
	<script src="http://js.leapmotion.com/leap-0.6.3.min.js"></script>
	<script type="text/javascript" src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
	<script type="text/javascript" src="http://libs.baidu.com/underscore/1.7.0/underscore-min.js"></script>
</head>
<body>
	
	<section class="interface" id="media">
		<audio id="audio" controls="true"></audio>
	</section>

	<canvas id="screen"></canvas>

	<script type="text/javascript">

		var mode = null; // window, ac, media, phone

		var config = {
			breakBetweenGestures: 500
		};

		var car = {

			windowsPosition: [
				0, // frontLeft
				0, // frontRight
				0, // rearLeft
				0 // rearRight
			], // 0: totally closed, 1: totally open

			airConditioner: {
				isOn: false,
				fanSpeed: 0,
				temperature: 25
			},

			media: {
				isOn: true,
				mode: 'radio', // radio, cd
				channel: 0, 
				volume: 0, // 0-1, step by 0.1
				playList: [
					"file:///Users/uicestone/Music/听见下雨的声音.mp3",
					"file:///Users/uicestone/Music/手写的从前.mp3",
					"file:///Users/uicestone/Music/鞋子特大号.mp3",
					"file:///Users/uicestone/Music/明明就.mp3",
				],
				fmChannels: [
					89.9,
					101.7,
					103.7
				]
			},

			phone: {
				status: 'not connected', // not connected, stand by, on the call, calling in
			}

		};

		var audioElement = document.getElementById('audio');

		audioElement.onended = function(){
			car.media.channel = car.media.channel === car.media.playList.length - 1 ? 0 : car.media.channel + 1;
		    audioElement.src = car.media.playList[car.media.channel];
		    audioElement.play();
			console.log('load: ' + car.media.playList[car.media.channel]);
		}

		var canvas = document.getElementById('screen'),
				context = canvas.getContext('2d');

		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		// Setup Leap loop with frame callback function
		var controller = new Leap.Controller({enableGestures: true});

		// to use HMD mode:
		// controllerOptions.optimizeHMD = true;
		var frames = [];
		var resumeAt = 0;

		var directions = [
			{
				name: 'x',
				sides: ['right', 'left']
			},
			{
				name: 'y',
				sides: ['up', 'down']
			},
			{
				name: 'z',
				sides: ['out', 'in']
			}
		];
		
		controller.on('frame', function(frame) {

			// no index finger data? next frame
			if(!frame.fingers[1])
				return;

			canvas.width = canvas.width; //clear
			
			//Get a pointable and normalize the tip position
			var hand = frame.hands[0];
			var interactionBox = frame.interactionBox;
			var normalizedIndexTipPosition = interactionBox.normalizePoint(frame.fingers[1].tipPosition, true);
			var normalizedPalmPosition = interactionBox.normalizePoint(frame.hands[0].palmPosition, true);

			// Convert the normalized coordinates to span the canvas
			var canvasX = canvas.width * normalizedIndexTipPosition[0];
			var canvasY = canvas.height * (1 - normalizedIndexTipPosition[1]);

			//we can ignore z for a 2D context
			var color = 128 - Math.round(hand.pinchStrength * 255 / 2);
			context.fillStyle = 'rgb(' + color + ', ' + color + ', ' + color + ')';
			context.beginPath();
			context.arc(canvasX, canvasY, 35 - hand.pinchStrength * 30, 0, Math.PI * 2 , true);
			context.closePath();
			context.fill();

			// if we are having a break between 2 gestures
			if(resumeAt && new Date() < resumeAt)
				return;

			if(frame.hands[0].confidence < 0.5)
				return;

			// console.info(frame.hands[0].grabStrength, frame.hands[0].pinchStrength);

			for(var i = frames.length - 2; i >= 0; i--){

				if(frames[i].fingers[1]){
					
					var diff = {};
					directions.forEach(function(direction, index){
						diff[direction.name] = frame.fingers[1].tipPosition[index] - frames[i].fingers[1].tipPosition[index];
					});

					var diffGrab = frame.hands[0].grabStrength - frames[i].hands[0].grabStrength;
					var diffPinch = frame.hands[0].pinchStrength - frames[i].hands[0].pinchStrength;

					try{
						directions.forEach(function(direction, index){

							if(Math.abs(diff[direction.name]) > 100){

								if(diff[direction.name] * frame.fingers[1].direction[index] > 0 && Math.abs(frame.fingers[1].direction[index]) > 0.33){
									frames = [];
									resumeAt = +new Date() + 100;

									var gesture = diff[direction.name] > 0 ? direction.sides[0] : direction.sides[1];

									throw 'gesture: ' + gesture;
								}

							}

						});

						if(Math.abs(diffGrab) > 0.6){
							// frames = [];
							// console.log(diffGrab, 'compare to frame ' + i, frames.length, frame.timestamp - frames[0].timestamp);
							var gesture = diffGrab > 0 ? 'grabTight' : 'grabLoose';
							throw 'gesture: ' + gesture;
						}

						if(Math.abs(diffPinch) > 0.7){
							// frames = [];
							var gesture = diffPinch > 0 ? 'pinchTight' : 'pinchLoose';
							throw 'gesture: ' + gesture;
						}


					}catch(message){

						console.info(message);
						
						if(message === 'gesture: left'){
							--car.media.channel;
							
							if(car.media.channel < 0){
								car.media.channel = car.media.playList.length - 1;
							}

							audioElement.src = car.media.playList[car.media.channel];
							audioElement.play();

							console.log('load: ' + car.media.playList[car.media.channel]);
						}

						if(message === 'gesture: right'){

							++car.media.channel;
							
							if(car.media.channel > car.media.playList.length - 1){
								car.media.channel = 0;
							}

							audioElement.src = car.media.playList[car.media.channel];
							audioElement.play();

							console.log('load: ' + car.media.playList[car.media.channel]);
						}

						if(message === 'gesture: grabLoose' && normalizedPalmPosition[0] > 1/3 && normalizedPalmPosition[0] < 2/3 && normalizedPalmPosition[1] < 1/3){
							
							if(!audioElement.src){
								audioElement.src = car.media.playList[car.media.channel];
							}

							audioElement.play();
						}

						if(message === 'gesture: grabTight' && Math.abs(normalizedPalmPosition[0]) > 1/3 && Math.abs(normalizedPalmPosition[0]) < 2/3 && normalizedPalmPosition[1] < 1/3){
							audioElement.load();
						}

						resumeAt = +new Date() + config.breakBetweenGestures;
						break;

						// return;
					}

				}

			}

			frames.push(frame);

			// console.log('new frame pushed');

			while(frame.timestamp - frames[0].timestamp > 200000){
				frames.shift();
				// console.log('head frame shifted');
			}

			// console.log('frames stored: ' + frames.length);

		});

		controller.on('gesture', function(gesture, frame){

			// if we are having a break between 2 gestures
			if(resumeAt && new Date() < resumeAt)
				return;

			// console.log(gesture.type, gesture.state, gesture, frame.pointables);

			var interactionBox = frame.interactionBox;
			var normalizedIndexTipPosition = frame.fingers[1] && interactionBox.normalizePoint(frame.fingers[1].tipPosition, true);
			var normalizedPalmPosition = interactionBox.normalizePoint(frame.hands[0].palmPosition, true);

			if(gesture.type === 'circle'){


				var increase = gesture.normal[2] < 0 ? true : false;
				var amount = 0.0001 * gesture.radius;

				!increase && (amount = -amount);

				var volume = audioElement.volume || 1.0;

				volume = volume + amount;

				if(volume > 1 || volume < 0){
					return;
				}

				if(car.media.volume.toFixed(1) !== volume.toFixed(1)){
					console.log('volume: ' + volume.toFixed(1));
				}

				audioElement.volume = car.media.volume = volume;
			}

			if(gesture.type === 'keyTap'){

				var gesturePointable = frame.pointables.filter(function(pointable){
					return pointable.id === gesture.pointableIds[0] && pointable.type === 0;
				})

				if(gesturePointable.length){
					if(audioElement.paused){
						console.log('resumed');
						audioElement.play()
					}else{
						console.log('paused');
						audioElement.pause();
					}
				}
			}

			if(gesture.type === 'screenTap'){
				
				if(normalizedIndexTipPosition[1] > 2/3){
					mode = 'window';
				}
				else if(normalizedIndexTipPosition[1] < 1/3){
					mode = 'ac';
				}
				else if(normalizedIndexTipPosition[0] > 2/3){
					mode = 'media';
				}
				else if(normalizedIndexTipPosition[0] < 1/3){
					mode = 'phone';
				}

				console.log('mode: ' + mode);

				$('.interface').hide();
				$('.interface#' + mode).show()

			}

			if(gesture.type === 'swipe'){

				// console.log(gesture, frame);

				directions.forEach(function(thisDirection, index){

					// console.log(thisDirection.name, gesture.direction[index],

					// 	directions.reduce(function(previous, current, index){
					// 		if(current.name !== thisDirection.name){
					// 			return previous && Math.abs(gesture.direction[index]) < 0.5;
					// 		}else{
					// 			return previous;
					// 		}
					// 	}, true)
					// );

					if(
						// distance of this direction >= 0.5
						Math.abs(gesture.direction[index]) >= 0.5
						&&
						// distances of both other 2 directions < 0.5
						directions.reduce(function(previous, current, index){
							if(current.name !== thisDirection.name){
								return previous && Math.abs(gesture.direction[index]) < 0.5;
							}else{
								return previous;
							}
						}, true)
					){
						resumeAt = +new Date() + config.breakBetweenGestures;
						var swipeDirecrtion = thisDirection.sides[gesture.direction[index] > 0 ? 0 : 1];
						console.info('gesture: swipe ' + swipeDirecrtion);

						if(swipeDirecrtion === 'down' && mode === 'media'){
							car.media.mode = car.media.mode === 'music' ? 'radio' : 'music';
							console.log('media mode: ' + car.media.mode);
						}
					}
				});
			}

		});

		controller.connect();

	</script>
</body>
</html>
