<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Leap Motion JavaScript Sample</title>
	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
		}
	</style>
	<script src="http://js.leapmotion.com/leap-0.6.3.min.js"></script>
	<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
</head>
<body>
	<audio id="audio" controls="true" src="file:///Users/uicestone/Music/听见下雨的声音.mp3" autoplay="true"></audio>
	<canvas id="screen"></canvas>
	<script type="text/javascript">

		var car = {

			windowsPosition: [
				0, // frontLeft
				0, // frontRight
				0, // rearLeft
				0 // rearRight
			], // 0: totally closed, 1: totally open

			airConditioner: {
				isOn: false,
				fanSpeed: 0,
				temperature: 25
			},

			media: {
				isOn: true,
				mode: 'radio', // radio, cd
				channel: 0, 
				volume: 0, // 0-1, step by 0.1
				playList: [
					"file:///Users/uicestone/Music/听见下雨的声音.mp3",
					"file:///Users/uicestone/Music/手写的从前.mp3",
					"file:///Users/uicestone/Music/鞋子特大号.mp3",
					"file:///Users/uicestone/Music/明明就.mp3",
				]
			},

			phone: {
				status: 'not connected', // not connected, stand by, on the call, calling in
			}

		};

		var canvas = document.getElementById('screen'),
				context = canvas.getContext('2d');

		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		// Setup Leap loop with frame callback function
		var controller = new Leap.Controller({enableGestures: true});

		// to use HMD mode:
		// controllerOptions.optimizeHMD = true;
		var frames = [];
		var resumeAt = 0;

		var directions = [
			{
				name: 'x',
				sides: ['right', 'left']
			},
			{
				name: 'y',
				sides: ['up', 'down']
			},
			{
				name: 'z',
				sides: ['out', 'in']
			}
		];
		
		controller.on('frame', function(frame) {

			// no index finger data? next frame
			if(!frame.fingers[1])
				return;

			// canvas.width = canvas.width; //clear
			
			// //Get a pointable and normalize the tip position
			// var hand = frame.hands[0];
			// var interactionBox = frame.interactionBox;
			// var normalizedIndexTipPosition = interactionBox.normalizePoint(frame.fingers[1].tipPosition, true);
			
			// // Convert the normalized coordinates to span the canvas
			// var canvasX = canvas.width * normalizedIndexTipPosition[0];
			// var canvasY = canvas.height * (1 - normalizedIndexTipPosition[1]);

			// //we can ignore z for a 2D context
			// var color = 255 - Math.round(hand.pinchStrength * 255);
			// context.fillStyle = 'rgb(' + color + ', ' + color + ', ' + color + ')';
			// context.beginPath();
			// context.arc(canvasX, canvasY, 100 - hand.pinchStrength * 100, 0, Math.PI * 2 , true);
			// context.closePath();
			// context.fill();

			// if we are having a break between 2 gestures
			if(resumeAt && new Date() < resumeAt)
				return;

			if(frame.hands[0].confidence < 0.5)
				return;

			for(var i = frames.length - 1; i >= 0; i--){

				if(frames[i].fingers[1]){
					
					var diff = {};
					directions.forEach(function(direction, index){
						diff[direction.name] = frame.fingers[1].tipPosition[index] - frames[i].fingers[1].tipPosition[index];
					});

					var diffGrab = frame.hands[0].grabStrength - frames[i].hands[0].grabStrength;
					var diffPinch = frame.hands[0].pinchStrength - frames[i].hands[0].pinchStrength;

					try{
						directions.forEach(function(direction, index){

							if(Math.abs(diff[direction.name]) > 100){

								if(diff[direction.name] * frame.fingers[1].direction[index] > 0 && Math.abs(frame.fingers[1].direction[index]) > 0.33){
									frames = [];
									resumeAt = +new Date() + 100;

									var gesture = diff[direction.name] > 0 ? direction.sides[0] : direction.sides[1];

									throw 'gesture: ' + gesture;
								}

							}

						});

						if(Math.abs(diffGrab) > 0.7){
							frames = [];
							var gesture = diffGrab > 0 ? 'grabTight' : 'grabLoose';
							throw 'gesture: ' + gesture;
						}

						if(Math.abs(diffPinch) > 0.7){
							frames = [];
							var gesture = diffPinch > 0 ? 'pinchTight' : 'pinchLoose';
							throw 'gesture: ' + gesture;
						}


					}catch(message){

						console.log(message);
						
						if(message === 'gesture: left'){
							audioElement.src = car.media.playList[--car.media.channel];
						}

						if(message === 'gesture: right'){
							audioElement.src = car.media.playList[++car.media.channel];
						}

						return;
					}

				}

			}

			frames.push(frame);

			while(frame.timestamp - frames[0].timestamp > 200000){
				frames.shift();
			}

			// console.log('frames stored: ' + frames.length);

		});

		controller.connect();

		var audioElement = document.getElementById('audio');


		controller.on('gesture', function(gesture, frame){

			// console.log(gesture.type, gesture.state, gesture, frame.pointables);

			if(gesture.type === 'circle'){


				var increase = gesture.normal[2] < 0 ? true : false;
				var amount = 0.0001 * gesture.radius;

				!increase && (amount = -amount);

				var volume = audioElement.volume || 1.0;

				volume = volume + amount;

				if(volume > 1 || volume < 0){
					return;
				}

				audioElement.volume = car.media.volume = volume;
			}

			if(gesture.type === 'keyTap'){

				var gesturePointable = frame.pointables.filter(function(pointable){
					return pointable.id === gesture.pointableIds[0] && pointable.type === 0;
				})

				if(gesturePointable.length){
					audioElement.paused ? audioElement.play() : audioElement.pause();
				}
			}

			if(gesture.type === 'swipe'){

				var gesturePointable = frame.pointables.filter(function(pointable){
					return pointable.id === gesture.pointableIds[0] && pointable.type === 1;
				})

				if(gesturePointable.length){
					// console.log(gesture.type, gesture.state, gesture, gesturePointable);
					audioElement.paused ? audioElement.play() : audioElement.pause();
				}
			}

		})

	</script>
</body>
</html>